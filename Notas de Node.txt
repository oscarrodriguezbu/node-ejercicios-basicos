- Todos los ejercicios de node del curso son expandibles y son fuertas para practicar
- Se usa prisma para bd sql y mongoose para mongoose
- Usar node v +18
- 

-------------------------------------
Seccion 2 fundamentos node
- Preguntas comunes sobre Node
- Hola Mundo en Node
- Laboratorio con FileSystem
- Code Execution
- Event Loop

Notas:
- Frameworks modernos  de front se basen en node
- Node como tal está orientado para el backend
- Al oprimir node en una consola, puedo hacer cosas en codigo y los cambios se van a reflejar en el navegador web
    Muy util para probar
- EL CODIGO SE EJECUTA EN BLOQUE O CASCAD NORMALMENTE Y ES BLOQUEANTE
- EN CASO DE EJECUCIONES COMPLEJAS, DEMORADAS O ASINCRONAS EL EVENT LOOP ES EL QUE DECIDE EL ORDEN
- CUANDO HAY ALGO ASINCRONO, SE USA LIBUV y es el encargado de reordenar la respuesta y devolverla, el orden puede que nunca sea igual
- 

-------------------------------------
Seccion 3 Desarrollando en Node
Puntualmente veremos:
- Package.json
- Node Modules
- Scripts
- Importaciones y Exportaciones
- Módulos
- Reforzamiento de JS
    - Callbacks
    - Arrow Functions
    - Factory Functions
    - Promises
    - Async Await
- Peticiones Http básicas
- Dependencias de Producción y Desarrollo
- Patrón adaptador para nuestras dependencias

Notas:
- npm init para crear el package json
- npm init -y para crear todo por defecto
- De los scripts npm start es espcial, cualquier otra cosa toca colocar npm run talCosa
- nodemon para trabajar con node sin correr npm start a toda hora
- nodemon no debe ir a produccion, al instarlo usar el -D y luego en el package json lo coloca en devDepencies
- Modificar los scripts del package json para correr nodemon
- Un Callback es una funcion que se pasa como parametro
- Factory Function es una funcion que crea otra funcion
- PATRON ADAPTADOR, ES POR SI QUEREMOS CAMBIAR O ACTUALIZAR LOS PAQUETES DE TERCERO SIN NINGUN PROBLEMA, en el proyecto estan como plugins
- El patron adaptador es una funcion que usa el paquete de tercero y se le mande algo para que el paquete de tercero haga lo que tenga que hacer y retorne un valor
    de esa manera la aplicación se hace mucho mas mantenible

-------------------------------------
Seccion 4 Bases de node + typescript continuacion
Puntualmente veremos:
- Loggers y su necesidad
- Winston
- Configuraciones básicas y adaptador
- TypeScript
- Configuración de TypeScript con Node
- Migración de proyecto
- TSC
- ts-node + nodemon
- Entre otras cosas


Notas:
- Winston es para revisar los logs, pero no es importante en produccion
- Al trabajar por ejemplo con nest, no es necesario configurar el typescript porque ya lo hace desde el principio

-------------------------------------
Seccion 5 INTRODUCCION AL TESTING
Esta sección tiene por objetivo comprender lo siguiente:
- ¿Qué es el testing automático?
- ¿Por qué es importante?
- Jest testing library
- Configuraciones Node + TS + Jest
- Pruebas en todos los archivos realizados en la sección anterior
- Coverage - Cobertura  del testing


Notas:
- Pruebas unitarias en pequeñas funcionalidades
- P de integracion, enfocadas en como reaccionan varias piezas en conjunto
- Pasos AAA: Arrange / Arreglar, Act / Actuar, Asert / Afirmar
- Probar la ruta critica para no tardar tanto
- Las implementacion de las pruebas pueden tardar un tiempo similar o mayor al desarrollo del codigo
- TDD consiste en hacer primero la prueba fallida y luego hacer el codigo para que pase la prueba, hay muchos patrones para hacer las pruebas
- Usar el testing por defecto del Framework, las mas populares son jest, jasmin y mocha
- Usar breakpoint: En visual studio code oprimir CTRL + SHIFT + P, colocar npm script y luego arrancar ya sea el test o el proyecto en desarrollo
- En las pruebas se puede trabajar con test asincronos y dentro colocarles el try y catch si es necesario
- Probar desde lo mas pequeño a lo mas grande
- Paquete rimraf para ayudar a conectar build y testing, desplegar build con npm run build

-------------------------------------
Seccion 6 Aplicacion de consola - Clean arquitecture - primeros pasos
- Funciones asíncronas auto-invocadas
- Argumentos de consola
- Banderas y opciones
- Yargs
- Configuración de Yargs
- Instalación de dependencias
    - Versión específica
    - Versión futura
    - Versión actual
- Casos de Uso

Notas:
- "dev:nodemon": "nodemon -b 7", en package json es para arrancar comandos con Banderas
- yargs es un paquete de terceros para trabajar con las banderas en consola

-------------------------------------
Seccion 7 Aplicacion de consola - testing
- Pruebas sobre comandos de consola
- Cambiar dinámicamente los argumentos de consola
- Mocks
- Spies
- Mocks y Spies con retornos personalizados
- Pruebas cuando se esperan errores
- Pruebas de Casos de Uso
- Pruebas de integración
- Pruebas con funciones asíncronas anónimas auto-invocadas
- Pruebas con yargs
- Pruebas con creación de archivos y directorios


-------------------------------------
Seccion 8 Aplicacion de Monitoreo - necesario
Esta sección empezaremos la creación del NOC, y puntualmente tocaremos temas como:
- Introducción a la Arquitectura Limpia
- Introducción a la inyección de dependencias (DI - Dependency injection)
- JSON-Server
- Casos de Uso
- CRON Task - Tareas cronometradas
Esta sección cuenta con una explicación de cómo lograremos el objetivo de la creación de nuestro 
sistema de monitoreo de forma global, que a lo largo de las próximas secciones lo haremos funcionar.

Notas:
- NOC - APP: Con esta aplicacion se pretende monitoriear un api, enviar correos.
- La estructura de la aplicacion de afuera hacia adentro como si fuera un circulo de la capa al nucleo: 
    Database ---> Presenters ---> Use Cases ---> Entities
- Grabar logs en fileSystem, PostgreSQL y MongoDB
- Arquitectura Limpia: No deberia de afectar si: Cambiamos la base de datos, cambiamos el motor de correos, añadimos o eliminamos tareas, queremos trabajar con multiples 
        origenes de datos
- En la arquitectura Limpia hay que crear mas archivos y directorios
- La intencion de este ejercicio es comprenderlo todo, mas adelante en otros proyectos del curso se va a seguir trabajando con ejercicios
- cron es para agregar tareas automaticas para no tener que colocar settimeout o algo asi
- json server es muy util para hacer prototipos  de restfull api por ejemplo
- La inyeccion de dependencias es baicamente lo que se hace en angular en el constructor

-------------------------------------
Seccion 9 cLEAN arquitecture - Respository pattern
En esta sección trabajaremos con el patron "Repository" para poder construir 
una forma intercambiable de orígenes de datos.

Puntualmente veremos:
- Entidades
- DataSources
- Repositorios
- Clases Abstractas
- Implementaciones
- Variables de entorno
- Validación de variables de entorno.

Notas:
- cotniene los origenes de los datos,  o de donde vienen
- repository son las reglas de como va a llegar la data a la bd
- env-war es para hacer validaciones de las variables de entorno
- Las variables de entorno siempre devuelven string y toca convertir si se necesita un numero o un booleano por ejemplo

-------------------------------------
seccion 10 Correos electronicos
En esta sección aprenderemos a enviar correos electrónicos con y sin archivos adjuntos.
Puntualmente veremos:
- Casos de Uso
- Servicios
- Inyecciones de dependencias
- Configuración de password en Gmail (secret keys)
- NodeMailer

Notas:
- Hay muchos gestores de correo pero son de pago, pero en esta seccion se usa nuestra cuenta de gmail
- Paquete Nodemailer para gestionar los correos en node
- Los paquetes de terceros se pueden gestionar por servicios ademas de plugins para que su implementacion sea facil de mantener

Resumen de las rutas:
- config: Van cosas como los plugis, axios, electronicos
- domain: Reglas con las que va a regir la aplicacion a nivel macro. Origines de datos, entities (como lucen los modelos o entidades), repository (es como quiero trabajar con datasources),
    casos de uso (Se ejeuctan diferentes acciones), infraestructure (implemtanciones del repositorio en donde se puede cambiar el datasource y el datasource), 
    presentation (cosas que estan cerca de los usuarios, estan los servicios que son como algo parecido a los plugis nombrados anteriormente)

-------------------------------------
Seccion 11 MongoDB y PostgreSQL
Esta sección es para integrar las bases de datos Mongo y PostgreSQL en nuestra aplicación de monitoreo, puntualmente veremos:
- Mongoose
- Prisma
- TypeORM (superficialmente)
- Migraciones de prisma
- Insertar en base de datos
- Leer de base de datos
- Mapeo de data a Entidades
- Creación de datasources
- Caso de uso nuevo, para grabar en múltiples destinos simultáneamente
Es una sección importante en la cual culminaremos nuestro proyecto de NOC.

Notas:
- Se usa mongoose para mongo y primsa para PostgreSQL
- Orden config mongo: Se configura mongoose, se crea el modelo, 
    configurar el 04-node-noc-fin-seccion-12\src\domain\datasources\log.datasource.ts,
    importar el datasource e inicializarlo en 04-node-noc-fin-seccion-12\src\infrastructure\datasources\mongo-log.datasource.ts,
    tener en cuenta la configuracion de 04-node-noc-fin-seccion-12\src\domain\entities\log.entity.ts,
    ajustar el server para guardar en la bd,

- orden config prisma: Oranizar el yml y los env, crear el schema.prisma, correr comando de migracion, 
    inicializar prisma en 04-node-noc-fin-seccion-12\src\infrastructure\datasources\postgres-log.datasource.ts,
    ajustar el server para guardar en la bd,

- Las migraciones muestra el estado actual y el estado anterior de la bd, puede ser util para hacer rollback en caso tal
- Para llamar los 3 modos de guardado, se hace en 04-node-noc-fin-seccion-12\src\domain\use-cases\checks\check-service-multiple.ts

-------------------------------------
Seccion 12 NOC- Testing - Clean arquitecture
Esta es otra sección de testing en la que nos enfocaremos en probar conceptos como clases abstractas, variables de entorno,
su configuración para el testing y más.

La idea principal es que como tenemos todo modularizado, debería de ser fácil probar cada pieza de forma individual.

También al final se explica que tener el 100% del coverage es tedioso en algunos casos porque hay que realizar muchas pruebas 
adicionales que técnicamente no deberían de ser necesarias.

Notas:
- Como el proyecto usa imagenes de bases de datos, toca hacer pruebas de esa forma, lo normal es que las bases de datos esten en la nube pero 
    para este ejercicio toca hacer cosas adicionales para poder probar la aplicacion
- Prober de lo que menos dependencias tenga hacia lo que mas tiene
- 

-------------------------------------
Seccion 13 WebServer - Http/http2

Notas:
- 

-------------------------------------
Seccion 14 RestServer

Notas:
- 

-------------------------------------
Seccion 15 RestServer + PostgreSQL

Notas:
- 

-------------------------------------
Seccion 16 Rest - Clean arquitecture

Notas:
- 

-------------------------------------
Seccion 17 Rest Testing

Notas:
- 

-------------------------------------
Seccion 18 Autenticacion y Autorizacion

Notas:
- 

-------------------------------------
Seccion 19 Enviar correo + validacion de tokens

Notas:
- 

-------------------------------------
Seccion 20 Proteccion de rutas, relaciones, middlewares y paginacion

Notas:
- 

-------------------------------------
Seccion 21 Relaciones y semillas

Notas:
- 

-------------------------------------
Seccion 22 Carga de archivos - simple y multiple

Notas:
- 

-------------------------------------
Seccion 23 webHooks

Notas:
- 

-------------------------------------
Seccion 24 Seguridad de webhooks

Notas:
- 

-------------------------------------
Seccion 25 edge functions con netlify

Notas:
- 

-------------------------------------
Seccion 26 websockets

Notas:
- 

-------------------------------------
Seccion 27 restapi + websockets - aplicación de colas

Notas:
- 

-------------------------------------
Seccion 

Notas:
- 

-------------------------------------