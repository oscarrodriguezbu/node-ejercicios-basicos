- Todos los ejercicios de node del curso son expandibles y son fuertas para practicar
- Se usa prisma para bd sql y mongoose para mongoose
- Usar node v +18
- 

-------------------------------------
Seccion 2 fundamentos node
- Preguntas comunes sobre Node
- Hola Mundo en Node
- Laboratorio con FileSystem
- Code Execution
- Event Loop

Notas:
- Frameworks modernos  de front se basen en node
- Node como tal está orientado para el backend
- Al oprimir node en una consola, puedo hacer cosas en codigo y los cambios se van a reflejar en el navegador web
    Muy util para probar
- EL CODIGO SE EJECUTA EN BLOQUE O CASCAD NORMALMENTE Y ES BLOQUEANTE
- EN CASO DE EJECUCIONES COMPLEJAS, DEMORADAS O ASINCRONAS EL EVENT LOOP ES EL QUE DECIDE EL ORDEN
- CUANDO HAY ALGO ASINCRONO, SE USA LIBUV y es el encargado de reordenar la respuesta y devolverla, el orden puede que nunca sea igual
- 

-------------------------------------
Seccion 3 Desarrollando en Node
Puntualmente veremos:
- Package.json
- Node Modules
- Scripts
- Importaciones y Exportaciones
- Módulos
- Reforzamiento de JS
    - Callbacks
    - Arrow Functions
    - Factory Functions
    - Promises
    - Async Await
- Peticiones Http básicas
- Dependencias de Producción y Desarrollo
- Patrón adaptador para nuestras dependencias

Notas:
- npm init para crear el package json
- npm init -y para crear todo por defecto
- De los scripts npm start es espcial, cualquier otra cosa toca colocar npm run talCosa
- nodemon para trabajar con node sin correr npm start a toda hora
- nodemon no debe ir a produccion, al instarlo usar el -D y luego en el package json lo coloca en devDepencies
- Modificar los scripts del package json para correr nodemon
- Un Callback es una funcion que se pasa como parametro
- Factory Function es una funcion que crea otra funcion
- PATRON ADAPTADOR, ES POR SI QUEREMOS CAMBIAR O ACTUALIZAR LOS PAQUETES DE TERCERO SIN NINGUN PROBLEMA, en el proyecto estan como plugins
- El patron adaptador es una funcion que usa el paquete de tercero y se le mande algo para que el paquete de tercero haga lo que tenga que hacer y retorne un valor
    de esa manera la aplicación se hace mucho mas mantenible

-------------------------------------
Seccion 4 Bases de node + typescript continuacion
Puntualmente veremos:
- Loggers y su necesidad
- Winston
- Configuraciones básicas y adaptador
- TypeScript
- Configuración de TypeScript con Node
- Migración de proyecto
- TSC
- ts-node + nodemon
- Entre otras cosas


Notas:
- Winston es para revisar los logs, pero no es importante en produccion
- Al trabajar por ejemplo con nest, no es necesario configurar el typescript porque ya lo hace desde el principio

-------------------------------------
Seccion 5 INTRODUCCION AL TESTING
Esta sección tiene por objetivo comprender lo siguiente:
- ¿Qué es el testing automático?
- ¿Por qué es importante?
- Jest testing library
- Configuraciones Node + TS + Jest
- Pruebas en todos los archivos realizados en la sección anterior
- Coverage - Cobertura  del testing


Notas:
- Pruebas unitarias en pequeñas funcionalidades
- P de integracion, enfocadas en como reaccionan varias piezas en conjunto
- Pasos AAA: Arrange / Arreglar, Act / Actuar, Asert / Afirmar
- Probar la ruta critica para no tardar tanto
- Las implementacion de las pruebas pueden tardar un tiempo similar o mayor al desarrollo del codigo
- TDD consiste en hacer primero la prueba fallida y luego hacer el codigo para que pase la prueba, hay muchos patrones para hacer las pruebas
- Usar el testing por defecto del Framework, las mas populares son jest, jasmin y mocha
- Usar breakpoint: En visual studio code oprimir CTRL + SHIFT + P, colocar npm script y luego arrancar ya sea el test o el proyecto en desarrollo
- En las pruebas se puede trabajar con test asincronos y dentro colocarles el try y catch si es necesario
- Probar desde lo mas pequeño a lo mas grande
- Paquete rimraf para ayudar a conectar build y testing, desplegar build con npm run build

-------------------------------------
Seccion 6 Aplicacion de consola - Clean arquitecture - primeros pasos
- Funciones asíncronas auto-invocadas
- Argumentos de consola
- Banderas y opciones
- Yargs
- Configuración de Yargs
- Instalación de dependencias
    - Versión específica
    - Versión futura
    - Versión actual
- Casos de Uso

Notas:
- "dev:nodemon": "nodemon -b 7", en package json es para arrancar comandos con Banderas
- yargs es un paquete de terceros para trabajar con las banderas en consola

-------------------------------------
Seccion 7 Aplicacion de consola - testing
- Pruebas sobre comandos de consola
- Cambiar dinámicamente los argumentos de consola
- Mocks
- Spies
- Mocks y Spies con retornos personalizados
- Pruebas cuando se esperan errores
- Pruebas de Casos de Uso
- Pruebas de integración
- Pruebas con funciones asíncronas anónimas auto-invocadas
- Pruebas con yargs
- Pruebas con creación de archivos y directorios


-------------------------------------
Seccion 8 Aplicacion de Monitoreo - necesario
Esta sección empezaremos la creación del NOC, y puntualmente tocaremos temas como:
- Introducción a la Arquitectura Limpia
- Introducción a la inyección de dependencias (DI - Dependency injection)
- JSON-Server
- Casos de Uso
- CRON Task - Tareas cronometradas
Esta sección cuenta con una explicación de cómo lograremos el objetivo de la creación de nuestro 
sistema de monitoreo de forma global, que a lo largo de las próximas secciones lo haremos funcionar.

Notas:
- NOC - APP: Con esta aplicacion se pretende monitoriear un api, enviar correos.
- La estructura de la aplicacion de afuera hacia adentro como si fuera un circulo de la capa al nucleo: 
    Database ---> Presenters ---> Use Cases ---> Entities
- Grabar logs en fileSystem, PostgreSQL y MongoDB
- Arquitectura Limpia: No deberia de afectar si: Cambiamos la base de datos, cambiamos el motor de correos, añadimos o eliminamos tareas, queremos trabajar con multiples 
        origenes de datos
- En la arquitectura Limpia hay que crear mas archivos y directorios
- La intencion de este ejercicio es comprenderlo todo, mas adelante en otros proyectos del curso se va a seguir trabajando con ejercicios
- cron es para agregar tareas automaticas para no tener que colocar settimeout o algo asi
- json server es muy util para hacer prototipos  de restfull api por ejemplo
- La inyeccion de dependencias es baicamente lo que se hace en angular en el constructor

-------------------------------------
Seccion 9 cLEAN arquitecture - Respository pattern
En esta sección trabajaremos con el patron "Repository" para poder construir 
una forma intercambiable de orígenes de datos.

Puntualmente veremos:
- Entidades
- DataSources
- Repositorios
- Clases Abstractas
- Implementaciones
- Variables de entorno
- Validación de variables de entorno.

Notas:
- cotniene los origenes de los datos,  o de donde vienen
- repository son las reglas de como va a llegar la data a la bd
- env-war es para hacer validaciones de las variables de entorno
- Las variables de entorno siempre devuelven string y toca convertir si se necesita un numero o un booleano por ejemplo

-------------------------------------
seccion 10 Correos electronicos
En esta sección aprenderemos a enviar correos electrónicos con y sin archivos adjuntos.
Puntualmente veremos:
- Casos de Uso
- Servicios
- Inyecciones de dependencias
- Configuración de password en Gmail (secret keys)
- NodeMailer

Notas:
- Hay muchos gestores de correo pero son de pago, pero en esta seccion se usa nuestra cuenta de gmail
- Paquete Nodemailer para gestionar los correos en node
- Los paquetes de terceros se pueden gestionar por servicios ademas de plugins para que su implementacion sea facil de mantener

Resumen de las rutas:
- config: Van cosas como los plugis, axios, electronicos
- domain: Reglas con las que va a regir la aplicacion a nivel macro. Origines de datos, entities (como lucen los modelos o entidades), repository 
    (es como quiero trabajar con datasources),
    casos de uso (Se ejeuctan diferentes acciones), infraestructure (implemtanciones del repositorio en donde se puede cambiar el datasource y el datasource), 
    presentation (cosas que estan cerca de los usuarios, estan los servicios que son como algo parecido a los plugis nombrados anteriormente)

-------------------------------------
Seccion 11 MongoDB y PostgreSQL
Esta sección es para integrar las bases de datos Mongo y PostgreSQL en nuestra aplicación de monitoreo, puntualmente veremos:
- Mongoose
- Prisma
- TypeORM (superficialmente)
- Migraciones de prisma
- Insertar en base de datos
- Leer de base de datos
- Mapeo de data a Entidades
- Creación de datasources
- Caso de uso nuevo, para grabar en múltiples destinos simultáneamente
Es una sección importante en la cual culminaremos nuestro proyecto de NOC.

Notas:
- Se usa mongoose para mongo y primsa para PostgreSQL
- Orden config mongo: Se configura mongoose, se crea el modelo, 
    configurar el 04-node-noc-fin-seccion-12\src\domain\datasources\log.datasource.ts,
    importar el datasource e inicializarlo en 04-node-noc-fin-seccion-12\src\infrastructure\datasources\mongo-log.datasource.ts,
    tener en cuenta la configuracion de 04-node-noc-fin-seccion-12\src\domain\entities\log.entity.ts,
    ajustar el server para guardar en la bd,

- orden config prisma: Oranizar el yml y los env, crear el schema.prisma, correr comando de migracion, 
    inicializar prisma en 04-node-noc-fin-seccion-12\src\infrastructure\datasources\postgres-log.datasource.ts,
    ajustar el server para guardar en la bd,

- Las migraciones muestra el estado actual y el estado anterior de la bd, puede ser util para hacer rollback en caso tal
- Para llamar los 3 modos de guardado, se hace en 04-node-noc-fin-seccion-12\src\domain\use-cases\checks\check-service-multiple.ts

-------------------------------------
Seccion 12 NOC- Testing - Clean arquitecture
Esta es otra sección de testing en la que nos enfocaremos en probar conceptos como clases abstractas, variables de entorno,
su configuración para el testing y más.

La idea principal es que como tenemos todo modularizado, debería de ser fácil probar cada pieza de forma individual.

También al final se explica que tener el 100% del coverage es tedioso en algunos casos porque hay que realizar muchas pruebas 
adicionales que técnicamente no deberían de ser necesarias.

Notas:
- Como el proyecto usa imagenes de bases de datos, toca hacer pruebas de esa forma, lo normal es que las bases de datos esten en la nube pero 
    para este ejercicio toca hacer cosas adicionales para poder probar la aplicacion
- Prober de lo que menos dependencias tenga hacia lo que mas tiene
- 

-------------------------------------
Seccion 13 WebServer - Http/http2
Esta sección tiene por objetivo aprender un poco sobre HTTP, Http2, Https y montar un WebServer con una aplicación corriendo en la web.

Puntualmente veremos:
- Crear un WebServer
    - Manual
    - Con express
- Variables de entorno
- Single Page Application + Router de Frontend
- Servir diferentes archivos
- Desplegar servidor en la nube
- GitHub
- Railway.


Notas:
- http2 es nuevo, al parecer es mas rapido y mas eficiente
- http2 debe tener el createSecureServer para que funcione y sea compatible
- http2 puede interpretarse como una conexion no segura pero es como https
- Express, Fastify => Nest.js facilitan mucho las configuraciones en node
- Instalar express, configurarlo como un server en la carpeta presentation, hacerlo funcionar en app.ts

-------------------------------------
Seccion 14 RestServer
En esta sección, nos enfocaremos en trabajar con un servidor rest y crear nuestra API.
Puntualmente veremos:

- CRUD
    - Create
    - Read
    - Updtate
    - Delete
    - Desplegar Restful server a la web
- Configurar las rutas y los controladores

La idea es dejar las bases de todo el servidor bien organizado, para después conectar una base de datos en 
la siguiente sección e implementar la arquitectura a su totalidad.


-------------------------------------
Seccion 15 RestServer + PostgreSQL
- Conectar Postgres a nuestros endpoints
- DTOs Pattern (Data Transfer Objects)
- Aprovisionar Postgres en la nube
- Desplegar aplicación

Es una sección donde aprenderemos de forma tradicional, como realizar las interacciones con la base de datos, 
pero sin aplicar arquitectura limpia, lo haremos de forma ordenada pero sencillas, que es como comúnmente ustedes lo verán allá afuera,
y luego en la siguiente sección aplicaremos la arquitectura en su totalidad.


********  Data Transfer Object DTO Definition and Usage: ********

A data transfer object (DTO) is an object that carries data between processes. You can use this technique to facilitate communication between two systems 
(like an API and your server) without potentially exposing sensitive information.

DTOs are commonsense solutions for people with programming backgrounds. If you're a developer, you probably know what these things are and how they work. 
If you're an average user, DTOs can be incredibly confusing.

We'll do our best to explain DTOs in plain language. But know that we may need to get a bit technical to highlight how they work.

What is a DTO?
As we explained, DTO stands for data transfer object. As the name suggests, a DTO is an object made to transfer data.

You'll use DTOs in object-oriented programming (OOP) language environments such as Python, C++, and Java. DTOs are easy to develop and update.

OOP environments rely on a system of "calls." Each one is a bit like a data lookup, and they require both time and processing speed. If you’re not careful, 
calls can also expose sensitive data you'd like to keep hidden, such as:

Employee addresses
Account numbers
Social Security numbers 
Business logins
As one programmer explainsopens in a new tab, you might require an employee's name and photo to enter your company. You need to provide that data for a match, 
but you don't need to give other information about the employee that you have within your database. A DTO can transfer only the information required.

How to put a DTO to use
A DTO should just contain data, not business logic. It's a simple, small thing that should do one task only.

A good DTOopens in a new tab will:

Minimize boilerplate. You'll write each one fresh.
Be easy to create. DTOs shouldn't be so complicated that you struggle to write them. (Code like this is easy to break.)
Be readable. Anyone should be able to parse your code.

***************

Notas:
- api para practicar: https://developer.themoviedb.org/reference/account-details
- el dto puede ser una clase o un objeto, cualquier cosa que asegure la data
- En el proyecto se crea un dto para actualizar y otro para crear todos, se usa para validar
- express validator facilita las validaciones

-------------------------------------
Seccion 16 Rest - Clean arquitecture
En esta sección, nos enfocaremos a trabajar mediante el patrón repositorio y la arquitectura limpia con casos de uso.

Es una sección opcional, pero recomendada, ya que aunque es importante, no quiere decir que es la única forma de trabajar, 
podemos usar el repositorio, controladores o inclusive los casos de uso directamente, pero si queremos implementarla a su totalidad, aquí tienen una guía al respecto.

En la sección del testing, pueden tomar el código fuente, o bien el suyo sin haber pasado por esta sección porque haremos pruebas de integración con el servidor, 
lo que significa que no probaremos los casos de uso, probaremos los servicios Rest directamente.


Notas:
- Se empieza creando el todo entity en la carpeta de domain
- en domain no debe haber nada externo que interfiera con la logica, nada de paquetes de terceros
- luego en doamin se crean las carpetas datasources (origenes de datos) y repositories (metodos para llegar al datasource)
- luego se construye el imp o implementation del datasource

-------------------------------------
Seccion 17 Rest Testing
Esta sección de testing, posiblemente es la más simple de todas,
 porque realizaremos pruebas de integración sobre nuestro servidor Rest.

La idea es que al llamar un endpoint, obtengamos la información deseada y esperada, 
si llamamos un método de creación, estamos esperando que se cree el elemento,
y realizaremos posteriormente las limpiezas respectivas.

Sólo vamos a probar aquí, lo que no hemos evaluado antes, por lo que la sección no es tan extensa.

Notas:
- se trabaja en esta ocasion como una especie de pruebas de integracion
- En tests\presentation\todos\routes.test.ts se usa supertest

-------------------------------------
Seccion 18 Autenticacion y Autorizacion
En esta sección nos vamos a enfocar en la creación de usuarios para nuestra aplicación, 
por lo cual ocuparemos:
- Preparar la base de datos
- Encriptar mediante un hash de unas sola vía las contraseñas
- Generar los tokens de acceso
- Preparar todo el backend

En esta sección comenzaremos de cero de nuevo.


Notas:
- carpeta domain son las reglas de negocio
- Se crea una forma que simplifica el manejo de los errores
- user entity es algo parecido al schema de mongoose pero sin depender de mongoose en caso tal haya que cambiarlo
- Se crea un dto para validar el request body del register
- JWT_SEED es cualquier cosa para generar y firmar los tokens

-------------------------------------
Seccion 19 Enviar correo + validacion de tokens
En esta sección realizaremos una verificación de correo electrónico y crearemos un túnel para 
poder conectarnos desde internet a nuestro localhost.

Puntualmente veremos:
- Envío de correo
- Creación de links de retorno
- ngrok para tunneling
- Variables de entorno para facilitar sus cambios
- Pruebas de conexión y validación desde el celular
- Pruebas hacia el localhost desde internet

Notas:
- Para lo del correo se usa la configuracion que se hizo en el repo:
    https://github.com/oscarrodriguezbu/02-node-noc/blob/main/src/presentation/email/email.service.ts
- se usa nrok para correr la aplicacion desde un celular, sirve para desplegar compartir el puerto del pc y mostrar
    lo que estamos haciendo rapidamente sin desplegar
- vscode actualmente tiene opciones para trabajar con puertos en la seccion donde esta la consola

-------------------------------------
Seccion 20 Proteccion de rutas, relaciones, middlewares y paginacion
Esta es una sección cargada de mucha información útil que va desde relaciones en nuestros modelos hasta 
la paginación, puntualmente veremos:

- Middlewares
- Rutas
- Modelos
- Validación de token
- Query parameters
- Estrategias de paginación
- Manejo de errores
- Consideración sobre uso de servicios y inyección de dependencias.


Notas:
- Se aconseja no colocar async y await en los controladores, pero se puede manejar con promeas con then y catch
- Si hay un dto como el paginador que se usa en varias rutas diferentes, entonces se puede crear en una carpeta shared

-------------------------------------
Seccion 21 Relaciones y semillas
En esta sección aprenderemos a trabajar con relaciones en nuestras 
colecciones de Mongo y cómo podemos generar una semilla para poblar la base de datos rápidamente.

Puntualmente veremos:
- Una nueva forma de DTO completa
- Validar MongoIDs
- Crear categorías, productos y usuarios desde una semilla
- Remover información en la serialización JSON


Notas:
- No ejecutar el seed en produccion, elimina toda la base de datos


-------------------------------------
Seccion 22 Carga de archivos - simple y multiple
En esta sección trabajaremos con la carga y lectura de archivos a nuestro servidor, puntualmente veremos:

- Carga Simple
- Carga Multiple
- Obtener archivos + Body de la petición http de forma simultánea
- Validaciones de archivo y extensiones
- Middlewares personalizados
- Almacenamiento en File System
- Obtención del archivo de la petición http

La idea es que podamos trabajar con la carga de archivos y colocarlos donde sea necesario, 
creando un código que nos permita su expansión y modificación después.


Notas:
- No subir archivos en el mismo servidor, pueden filtrar contenido malisioso
- Los archivos pueden pasar por el backend pero no se recomienda que se guarden ahí
- Se usan dos paquetes para la carga de los archivos, el uuid y el express-fileupload

-------------------------------------
Seccion 23 webHooks
En esta sección trabajaremos con webhooks, con los cuales vamos a crear una aplicación que sea capaz de 
comunica Github con Discord mediante nuestro servidor.

Puntualmente veremos:

-¿Qué son los webhooks? (Explicación)
-Como funcionan
-Configurar los webhooks de:
    -Github
    -Discord
-Crear un canal de discord para recibir los mensajes de nuestro server
-Envio de imágenes a Discord
-Creación de variables de entorno y todo lo necesario para que esto funcione.



Notas:
- Sirve mucho para hacer pagos, tambien para hacer seguimiento a paginas como github o hacer cositas en discord
- Tiene riesgos pero al crear los endpoints es muy importante el secret token

Mas info:
https://docs.github.com/en/webhooks/using-webhooks/creating-webhooks
https://www.youtube.com/watch?v=41NOoEz3Tzc


-------------------------------------
Seccion 24 Seguridad de webhooks
Esta sección es bastante es bastante corta, porque nos enfocaremos únicamente en la verificación de los headers de 
autenticación que nos ofrece Github.

Puntualmente veremos:
- Headers de petición personalizados
- Middleware de autenticación
- Bloqueo de peticiones no válidas


Notas:
- Siempre seguir la documentacion oficial para hacer las implementaciones, ya sea paypal, github, etc...

Mas info:
https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries


-------------------------------------
Seccion 25 edge functions con netlify
En esta sección trabajaremos creando pequeñas funciones que nos permitan desplegarlas en la nube, 
y así evitar tener que crear todo un servidor que se encuentre corriendo el 100% del tiempo, en la espera de peticiones http esporádicas.

Lo que veremos es muy utilizado para abaratar costos y desplegar procedimientos en la nube. Hay muchos
servicios que ofrecen este tipo de funciones en la nube (edge functions) que te permitirán realizar lo que
necesites, pero en esta sección lo haremos con Netlify por su capa gratuita y funcional.


Notas:
- Se toma la seccion anterior (https://github.com/oscarrodriguezbu/05-webhooks-server), se eliminan cositas y se sube a netlify

Mas info 
https://www.netlify.com/
https://docs.netlify.com/api-and-cli-guides/cli-guides/get-started-with-cli/


-------------------------------------
Seccion 26 websockets
En esta sección comenzaremos a trabajar con los websockets, los cuales son una forma de comunicación Activa-Activa, 
es decir tanto el cliente como el servidor pueden iniciar el canal de comunicación, lo que le da el poder al servidor 
de mandar mensajes que un cliente puede estar interesado.

Puntualmente veremos:

- ¿Qué son los websockets?
- Librerías para websockets
- Implementación Nativa del navegador web para WS
- WS Library para nuestro servidor
- Configuración mínima en el servidor
- Broadcasts
    - Cliente
    - Servidor
- Re-conexión manual en caso de perdida de comunicación


Notas:
- websockets Es una comunicacion bilateral
- 


Mas info:
https://www.npmjs.com/package/ws
https://developer.mozilla.org/en-US/docs/Web/API/WebSocket
https://www.npmjs.com/package/ws

-------------------------------------
Seccion 27 restapi + websockets - aplicación de colas
El objetivo de esta sección es conectar los Websockets con nuestro Restful API ya así poder disparar 
la comunicación en tiempo real cuando los eventos sucedan.

Pero para hacer más entretenido el aprendizaje, crearemos una aplicación de colas, 
similar a la que se utiliza en lugares donde hay salas de espera, para que la persona imprima 
un papel con su número y hay una pantalla que muestra cuál es el ticket que se está atendiendo y en dónde.

Puntualmente aprenderemos y reforzaremos:
- Websockets
- Restful
- Conectar WebSockets con Restful
- Vanilla JavaScript para el frontend
- Servicios
- Lógica relacionada para el funcionamiento de la aplicación


-------------------------------------